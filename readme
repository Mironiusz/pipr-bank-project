Program napisany przez: Rafał Mironko

Program jest symulatorem banku udzielającego kredytów swoim klientom.
Umożliwia klientom branie kredytów na różne kwoty i z różnym oprocentowaniem.
Kredyt jest uproszczony - jednynymi zmiennymi są: oprocentowanie, liczba rat, wysokość raty.
Program jest graficzny i interaktywny.
Symulator umożliwia przyspieszenie czasu - można zobaczyć, jaki jest stan zadłużenia klientów
i stan aktywów banku po upływie kilku miesięcy.


Program jest podzielony na klasy znajdujące się w plikach o takich samych nazwach:

- Client - zawiera dane o kliencie. Unikalne id, imię i nazwisko.
- Loan - zawiera dane o kredycie. Unikalne id, id klienta biorącego pożyczkę,
        kwota kredytu, oprocentowanie, ilość rat, ilość pozostałych rat, kwota jednej raty.
- App - zawiera główną część kodu. Całe GUI i logika.

Program jest uruchamiany z pliku main.py

Program zawiera plik functions.py, odpowiedzialny za wszystkie powtarzalne funkcje wewnątrz kodu.

Funkcje i wszystkie zmienne są nazwane tak, żeby była znana ich funkcjonalność - nawet kosztem
długiej nazwy. Do tego są opisane odpowiednimi komentarzami


Kluczową częścią programu są trzy pliki tekstowe - bank.txt, clients.txt i loans.txt.

- bank.txt - przetrzymuje informację o stanie konta banku
- clients.txt - jest bazą danych o wszystkich klientach, w formacie .csv
- loans.txt - jest bazą danych o wszystkich kredytach, w formacie .csv

W pliku bank.txt możemy ustawić początkowy stan konta banku. Robi się to ręcznie zmieniając
zawartość pliku. Domyślną wartością jest milion złotych.

W plikach loans.txt i clients.txt możemy ręcznie usunąć kredyty i klientów. Nie zaleca się
ręcznie dodawać nowych wartości ani modyfikować istniejących.

Plik test_Bank.py zawiera testy jednostkowe funkcji z pliku functions.py


ZAKRES WYKONANYCH PRAC - CZĘŚĆ REFLEKSYJNA

Jestem zadowolony z programu, który napisałem. Mimo mojego braku doświadczenia w programowaniu
w językach opartych na klasach i widocznych naleciałości z języków eventowo-funkcyjno-reaktywnych
(javascript, Vue.js), program działa, a kod jest czytelny.

Chciałem dodać do programu trochę więcej narracji, jak to się stało, że jest rok 1995,
dodać funkcjonalność związaną z nowymi stylami graficznymi podczas przyspieszania czasu,
jednak okazało się to bardzo czasochłonne i trudne. Konieczność wykorzystania wielowątkowości,
dodatkowych messageboxów, pasków wczytywania i refaktoryzacja plików tekstowych skutecznie zniechęciła
mnie do wdrożenia tego pomysłu.

Prawdopodobnie powinienem od początku lepiej rozplanować podział na klasy pliku app.py,
zamiast wrzucać wszystko do jednej klasy App. Przez brak dogłębnej znajomości biblioteki tkinter
często trafiałem na problemy w rozdzielaniu tworzenia elementów GUI od ich wywoływania w głównym pliku.
Jest to rzecz, która zdecydowanie wymaga poprawy w moich przyszłych projektach.

Podobnym problemem był dla mnie brak znajomości wzorców projektowych języków opartych na klasach.
W internecie znalazłem trochę informacji, jednak były albo szczątkowe, albo bardzo niejasne.
Uważam, że przed wykonaniem takiego projektu powinniśmy zostać chociaż w niewielkim stopniu
przeszkoleni z obowiązujących wzorców projektowych. Bez tego wszyscy, którzy nie mieli wcześniej
doświadczenia w planowaniu struktury kodu, mają bardzo utrudnione zadanie i nie wiedzą, na co zwracać uwagę.

Największą przeszkodą był dla mnie sam Python i konstruowanie klas rozbitych na kilka plików.
Nie byłem w stanie stworzyć funkcji w zewnętrzym pliku używającej argumentu self głównej klasy.
Nie wiedziałem też, jak mogę rozdzielić niektóre elementy tkintera od głównej klasy - głównie
przez konieczność konfigurowania ich z poziomu funkcji. Przez to, że funkcje mają lokalny scope, jeśli
nie podamy im argumentu self, nie jesteśmy w stanie konfigurować elementów tkintera z poziomu
zewnętrznych funkcji. Dlatego umieściłem je wewnątrz App.